# Словарь для перевода слов в числа (до 999)
# Поддерживает альтернативные формы ("ноль" и "нуль")
WORD_TO_NUM = {
    'ноль': 0, 'нуль': 0,
    'один': 1, 'два': 2, 'три': 3, 'четыре': 4, 'пять': 5,
    'шесть': 6, 'семь': 7, 'восемь': 8, 'девять': 9,
    'десять': 10, 'одиннадцать': 11, 'двенадцать': 12, 'тринадцать': 13, 'четырнадцать': 14,
    'пятнадцать': 15, 'шестнадцать': 16, 'семнадцать': 17, 'восемнадцать': 18, 'девятнадцать': 19,
    'двадцать': 20, 'тридцать': 30, 'сорок': 40, 'пятьдесят': 50,
    'шестьдесят': 60, 'семьдесят': 70, 'восемьдесят': 80, 'девяносто': 90,
    'сто': 100, 'двести': 200, 'триста': 300, 'четыреста': 400, 'пятьсот': 500,
    'шестьсот': 600, 'семьсот': 700, 'восемьсот': 800, 'девятьсот': 900,
}


def word_to_number(words):
    """
    Преобразует список слов (например, ['двадцать', 'три']) в число.
    Просто суммирует значения из словаря WORD_TO_NUM.
    Предполагается, что слова уже упорядочены правильно (например, 'двадцать три', а не 'три двадцать').
    """
    total = 0
    for w in words:
        if w not in WORD_TO_NUM:
            raise ValueError(f"Неизвестное слово в числе: {w}")
        total += WORD_TO_NUM[w]
    return total


def parse_expression(text):
    """
    Разбирает текстовое математическое выражение на русском языке
    и возвращает список токенов: числа и операторы ('+', '-', '*', '/').
    
    Поддерживает:
      - положительные и отрицательные числа (через "минус два")
      - однословные операции: "плюс", "минус"
      - двухсловные операции: "умножить на", "поделить на"
      
    Важно: порядок обработки критичен — сначала пробуем распознать отрицательное число,
    и только если после "минус" нет числа — считаем его операцией вычитания.
    """
    words = text.lower().split()
    tokens = []
    i = 0

    while i < len(words):
        # === Этап 1: попытка прочитать число (возможно, с минусом) ===
        is_negative = False
        number_words = []

        # Проверяем, начинается ли текущий фрагмент с "минус"
        if words[i] == 'минус':
            j = i + 1
            temp_words = []
            # Собираем все подряд идущие числительные после "минус"
            while j < len(words) and words[j] in WORD_TO_NUM:
                temp_words.append(words[j])
                j += 1
            # Если после "минус" есть хотя бы одно число — это отрицательное число
            if temp_words:
                is_negative = True
                number_words = temp_words
                i = j  # перемещаем указатель за прочитанные слова
            else:
                # Иначе "минус" — это операция вычитания; обработаем позже
                pass
        else:
            # Обычное (положительное) число: собираем все числительные подряд
            while i < len(words) and words[i] in WORD_TO_NUM:
                number_words.append(words[i])
                i += 1
            # Если не нашли ни одного числительного — ошибка
            if not number_words:
                raise ValueError(f"Ожидалось число, получено: {words[i]}")

        # Если собрали число — добавляем его в токены
        if number_words:
            num = word_to_number(number_words)
            if is_negative:
                num = -num
            tokens.append(num)
        else:
            # Если не собрали число, значит, сейчас должен быть оператор
            # Но мы пока не знаем какой — перейдём к следующему этапу
            pass

        # === Этап 2: чтение оператора (если ещё не конец строки) ===
        if i >= len(words):
            break  # выражение закончилось

        # Проверяем двухсловные операторы ("умножить на", "поделить на")
        if i + 1 < len(words):
            op_phrase = f"{words[i]} {words[i+1]}"
            if op_phrase == "умножить на":
                tokens.append('*')
                i += 2
                continue
            elif op_phrase == "поделить на":
                tokens.append('/')
                i += 2
                continue

        # Проверяем однословные операторы
        if words[i] == 'плюс':
            tokens.append('+')
            i += 1
            continue
        elif words[i] == 'минус':
            tokens.append('-')
            i += 1
            continue

        # Если ничего не подошло — ошибка
        raise ValueError(f"Неизвестная операция: '{words[i]}'")

    return tokens


def evaluate_tokens(tokens):
    """
    Вычисляет результат выражения, заданного списком токенов вида [число, оператор, число, ...].
    Поддерживает только линейные выражения без приоритета операций (вычисление слева направо).
    Например: "2 + 3 * 4" будет вычислено как (2 + 3) * 4 = 20.
    """
    if not tokens:
        raise ValueError("Пустое выражение")
    
    # Первый токен обязан быть числом
    result = tokens[0]
    i = 1

    # Проходим по парам: оператор + операнд
    while i < len(tokens):
        if i + 1 >= len(tokens):
            raise ValueError("Неполное выражение: не хватает операнда после оператора")
        
        op = tokens[i]
        operand = tokens[i + 1]

        if op == '+':
            result += operand
        elif op == '-':
            result -= operand
        elif op == '*':
            result *= operand
        elif op == '/':
            if operand == 0:
                raise ZeroDivisionError("Деление на ноль")
            result /= operand
        else:
            raise ValueError(f"Неизвестная операция: {op}")
        
        i += 2  # переходим к следующей паре

    # Если результат целый — возвращаем int, иначе float
    return int(result) if isinstance(result, float) and result.is_integer() else result


def calculate(text):
    """
    Основная функция: принимает строку с выражением на русском,
    разбирает её, вычисляет и возвращает результат.
    Оборачивает возможные ошибки в понятное сообщение.
    """
    try:
        tokens = parse_expression(text)
        return evaluate_tokens(tokens)
    except Exception as e:
        raise ValueError(f"Ошибка при вычислении выражения '{text}': {e}")


def run_tests():
    """
    Набор автоматических тестов для проверки корректности работы калькулятора.
    Проверяет базовые арифметические операции, отрицательные числа, деление и т.д.
    """
    test_cases = [
        ("тридцать три поделить на три", 11),
        ("два плюс два плюс два", 6),
        ("минус два умножить на двадцать", -40),
        ("десять минус пять", 5),
        ("нуль плюс один", 1),
        ("минус один плюс два", 1),
        ("сто двадцать три поделить на три", 41),
        ("минус пять умножить на минус пять", 25),
        ("двадцать плюс тридцать", 50),
        ("минус десять плюс пять", -5),
        ("один плюс два плюс три плюс четыре", 10),
        ("девяносто девять поделить на девять", 11),
        ("двадцать три плюс семь", 30),
        ("сто пятьдесят два поделить на два", 76),
        ("минус тридцать три плюс тридцать три", 0),
        ("ноль плюс ноль", 0),
        ("минус ноль", 0),
        ("девяносто девять поделить на три", 33),
        ("два умножить на три", 6),
        ("пятьдесят пять поделить на пять", 11),
    ]
    
    print("Запуск тестов...")
    passed = 0
    for expr, expected in test_cases:
        try:
            result = calculate(expr)
            if abs(result - expected) < 1e-9:  # учёт float-погрешности
                print(f"'{expr}' → {result}")
                passed += 1
            else:
                print(f"'{expr}' → {result} (ожидается {expected})")
        except Exception as e:
            print(f"'{expr}' → ОШИБКА: {e}")
    
    print(f"\nУспешно пройдено: {passed}/{len(test_cases)}")
    return passed == len(test_cases)


if __name__ == "__main__":
    # Запуск автоматических тестов
    all_passed = run_tests()
    
    if all_passed:
        print("\nВсе тесты пройдены! Калькулятор соответствует техническому заданию.\n")
    else:
        print("\nНекоторые тесты не прошли. Проверьте логи выше.\n")
    
    # Интерактивный режим: пользователь может вводить выражения
    print("Введите математическое выражение на русском языке.")
    print("Примеры:")
    print('   "два плюс три"')
    print('   "минус пять умножить на десять"')
    print('   "сто поделить на двадцать"')
    print('   "ноль минус один"')
    print("\nВведите 'выход', чтобы завершить.\n")

    while True:
        try:
            user_input = input("> ").strip()
            if not user_input:
                continue
            if user_input.lower() in ('выход', 'exit', 'quit'):
                print("До свидания!")
                break
            result = calculate(user_input)
            print(f"= {result}\n")
        except KeyboardInterrupt:
            print("\n\nДо свидания!")
            break
        except Exception as e:
            print(f"Ошибка: {e}\n")